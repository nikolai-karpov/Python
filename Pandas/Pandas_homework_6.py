# ПРИЗНАКИ: КАТЕГОРИАЛЬНЫЕ И ЧИСЛОВЫЕ
import pandas as pd

melb_data = pd.read_csv('data/melb_data_ps.csv', sep=',')

# чтобы не переопределять переменную melb_data и тем самым не повредить первоначальный DataFrame, 
# создадим копию melb_df с помощью метода copy():
melb_df = melb_data.copy()


# КАТЕГОРИИ В ДАННЫХ О НЕДВИЖИМОСТИ

# Давайте определим число уникальных категорий в каждом столбце нашей таблицы melb_df. Для этого создадим вспомогательную таблицу unique_counts:
unique_list = []                                            # создаём пустой список
for col in melb_df.columns:                                 # пробегаемся по именам столбцов в таблице
    item = (col, melb_df[col].nunique(),melb_df[col].dtype) # создаём кортеж (имя столбца, число уникальных значений)
    unique_list.append(item)                                # добавляем кортеж в список
unique_counts = pd.DataFrame(                               # создаём вспомогательную таблицу 
    unique_list,
    columns=['Column_Name', 'Num_Unique', 'Type']           # даём названия его столбцам: Column_Name, Num_unique и Type.
).sort_values(by='Num_Unique',  ignore_index=True)          # Сортируем по столбцу Num_unique в порядке возрастания количества уникальных элементов


# ТИП ДАННЫХ CATEGORY

# Для хранения и оптимизации работы с категориальными признаками в Pandas предусмотрен специальный тип данных — category.
# Сделаем преобразование столбцов к типу данных category:
cols_to_exclude = ['Date', 'Rooms', 'Bedroom', 'Bathroom', 'Car']           # список столбцов, которые мы не берём во внимание
max_unique_count = 150                                                      # задаём максимальное число уникальных категорий
for col in melb_df.columns:                                                 # цикл по именам столбцов
    if melb_df[col].nunique() < max_unique_count and col not in cols_to_exclude: # проверяем условие
        melb_df[col] = melb_df[col].astype('category')                      # преобразуем тип столбца


# ПОЛУЧЕНИЕ АТРИБУТОВ CATEGORY
# У типа данных category есть свой специальный аксесcор cat
print(melb_df['Regionname'].cat.categories) # список уникальных категорий в столбце Regionname:
print(melb_df['Regionname'].cat.codes)      # посмотрим, каким образом столбец кодируется в виде чисел в памяти компьютера


# С помощью метода аксессора rename_categories() можно легко переименовать текущие значения категорий. 
# Для этого в данный метод нужно передать словарь, 
# ключи которого — старые имена категорий, 
# а значения — новые.

# Рассмотрим на примере: переименуем категории признака типа постройки Type — заменим их на полные названия 
# (напомним, u — unit, h — house, t — townhouse).
melb_df['Type'] = melb_df['Type'].cat.rename_categories({
    'u': 'unit',
    't': 'townhouse',
    'h': 'house'
})
print(melb_df['Type'])

# ПОДВОДНЫЕ КАМНИ
# category хранит только категории, которые были объявлены при его инициализации. 
# При встрече с новой, неизвестной ранее категорией, этот тип превратит её в пустое значение, так как он просто не знает о существовании этой категории.
# Решить эту проблему можно добавив категорию flat в столбец Type с помощью метода акссесора cat add_categories(), 
# в который достаточно просто передать имя новой категории:
melb_df['Type'] = melb_df['Type'].cat.add_categories('flat')
new_houses_types = pd.Series(['unit', 'house', 'flat', 'flat', 'house'])
new_houses_types = new_houses_types.astype(melb_df['Type'].dtype)


# Из данного примера можно сделать вывод, 
# что если набор категорий в столбце жёстко не зафиксирован и может обновляться в процессе работы, 
# то тип category не является подходящим типом данных для этого столбца 
# или необходимо постоянно писать проверки при обновлении таблицы.


# Несколько рекомендаций по использованию:
# 1 Необязательно каждый раз преобразовывать категориальные данные в тип данных category. 
#   Зачастую это делается исключительно для оптимизации работы с большими данными.
# 2 Если набор данных занимает значительный процент используемой оперативной памяти, рассмотрите возможность использования типа category.
# 3 Если у вас очень серьёзные проблемы с производительностью, обратите внимание на использование типа category.
# 4 Если вы решили использовать тип category, будьте осторожны при добавлении новой информации в вашу таблицу. 
#   Убедитесь, что вы собрали всю необходимую информацию, произведите предобработку данных и только после этого используйте преобразование типов.


# Преобразуйте признак Suburb следующим образом: 
# оставьте в столбце только 119 наиболее популярных пригородов, остальные замените на 'other'.
popular_suburb = melb_df['Suburb'].value_counts().nlargest(119)
melb_df['Suburb'] = melb_df['Suburb'].apply(lambda x: x if x in popular_suburb else 'other')
melb_df['Suburb'] = melb_df['Suburb'].astype('category')        # Приводим данные в столбце Suburb к категориальному типу.

