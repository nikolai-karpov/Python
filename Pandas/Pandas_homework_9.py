import pandas as pd
ratings1 = pd.read_csv('data/movies_data/ratings1.csv')
ratings2 = pd.read_csv('data/movies_data/ratings2.csv')
# userId — уникальный идентификатор пользователя, который выставил оценку
# movieId — уникальный идентификатор фильма
# rating — рейтинг фильма


movies = pd.read_csv('data/movies_data/movies.csv')     # movies — таблица с информацией о фильмах.
# movieId — уникальный идентификатор фильма;
# title — название фильма и год его выхода;
# genres — жанры фильма.


dates = pd.read_csv('data/movies_data/dates.csv')       # dates — таблица с датами выставления всех оценок
dates['date'] = pd.to_datetime(dates['date'])           # date — дата и время выставления оценки фильму.


# Сколько уникальных фильмов nunique представлено в таблице movies?
print(movies.nunique)

# Сколько уникальных пользователей в таблице ratings1?
print(ratings1.value_counts())

# В каком году было выставлено больше всего оценок .mode()?
years_rating = dates['date'].dt.year
print('Mode year ratings:', years_rating.mode()[0])


# Объединение DataFrame: concat
# Функция Pandas concat() позволяет склеивать (конкатенировать) таблицы как по строкам, так и по столбцам.
# Вызов функции pd.concat()
# objs — список объектов DataFrame ([df1, df2,…]), которые должны быть сконкатенированы;
# axis — ось определяет направление конкатенации: 0 — конкатенация по строкам (по умолчанию), 1 — конкатенация по столбцам;
# join — либо inner (пересечение), либо outer (объединение); рассмотрим этот момент немного позже;
# ignore_index — по умолчанию установлено значение False, 
# которое позволяет значениям индекса оставаться такими, какими они были в исходных данных. 
# Если установлено значение True, параметр будет игнорировать исходные значения и повторно назначать значения индекса в последовательном порядке.

# Для корректной конкатенации по строкам объединяемые таблицы должны иметь одинаковую структуру — идентичное число и имена столбцов.
ratings = pd.concat(
    [ratings1, ratings2],
    ignore_index=True # нужно выставить параметр ignore_index на True чтобы не задвоились индексы с двух таблиц
)


# Давайте узнаем количество строк в таблицах ratings и dates, ведь нам предстоит объединять их по столбцам:
print('Число строк в таблице ratings: ', ratings.shape[0])
print('Число строк в таблице dates: ', dates.shape[0])
print(ratings.shape[0] == dates.shape[0])


# Чтобы очистить таблицу от дублей, мы можем воспользоваться методом DataFrame drop_duplicates()
ratings = ratings.drop_duplicates(ignore_index=True)
print('Число строк в таблице ratings: ', ratings.shape[0])


# добавить к нашей таблице с оценками даты их выставления
ratings_dates = pd.concat([ratings, dates], axis=1)
print(ratings_dates.tail(7))


# Объединение DataFrame: join, merge
# inner (внутреннее). Строки, для которых совпадение не было найдено, удаляются.
# outer (внешнее)
# full — используется как outer по умолчанию, объединяет все варианты в обеих таблицах.
# left — для всех записей из «левой» таблицы (например, ratings) ведётся поиск соответствий в «правой»
# right — аналогично предыдущему, но остаются значения только из «правой» таблицы. 
# В результирующей таблице останутся только те значения, которым были найдены соответствия


# МЕТОД ОБЪЕДИНЕНИЯ JOIN
# Для объединения двух таблиц по индексам
# данный метод можно применить и для того, чтобы объединить таблицы по ключевому столбцу

# При объединении таблица которую присоединяем является «правой», 
# а исходная таблица, от имени которой вызывается метод, является «левой».
# how — параметр типа объединения. По умолчанию параметр установлен на 'left'
# Он может принимать значения 'inner', 'left' (left outer), 'right' (right outer), и 'outer' (full outer).
# on — параметр, который определяет, по какому столбцу в «левой» таблице происходит объединение по индексам из «правой».
# lsuffix и rsuffix — дополнения (суффиксы) к названиям одноимённых столбцов в «левой» и «правой» таблицах.


joined = ratings_dates.join(    # Чтобы совместить таблицы по ключевому столбцу с помощью метода join()
    movies.set_index('movieId'),# необходимо использовать ключевой столбец в «правой» таблице в качестве индекса
    on='movieId',               # необходимо указать название ключа в параметре on.
    how='left'
)
# В результате такого объединения мы 
# для каждого идентификатора фильма movieId в таблице ratings_dates 
# нашли совпадающий с ним идентификатор movieId в таблице movies 
# и присоединили информацию о самом фильме (title и genres).
# в результате такого объединения у нас остался лишь один столбец movieId.


# МЕТОД ОБЪЕДИНЕНИЯ MERGE
# предлагает более гибкий способ управления объединением, благодаря чему является более популярным.
# right — присоединяемая таблица. По умолчанию она является «правой».
# how — параметр типа объединения. По умолчанию принимает значение 'inner'.
# on — параметр, который определяет, по какому столбцу происходит объединение. Определяется автоматически, но рекомендуется указывать вручную.
# left_on — если названия столбцов в «левой» и «правой» таблицах не совпадают, то данный параметр отвечает за наименования ключевого столбца исходной таблицы.
# right_on — аналогично предыдущему, параметр отвечает за наименование ключевого столбца присоединяемой таблицы.
# lsuffix и rsuffix — дополнения (суффиксы) к названиям одноимённых столбцов в «левой» и «правой» таблицах.


# Произведём слияние наших таблиц и получим ту же таблицу, что и ранее:
merged = ratings_dates.merge(
    movies,
    on='movieId',
    how='left'
)


# ОСОБЕННОСТИ ИСПОЛЬЗОВАНИЯ MERGE()
# Для объединения двух таблиц по индексам с помощью метода merge() необходимо установить значение параметров left_index и right_index на True.
# почему мы выбрали тип объединения left, а не full, например?
merged2 = ratings_dates.merge(
    movies,
    on='movieId',
    how='outer'
)
print('Число строк в таблице merged2: ', merged2.shape[0])
# Результирующее число строк в таблице увеличилось.
# в таблице movies содержались фильмы, которым ещё не были выставлены оценки
# мы дополнительно извлекли из таблицы movies информацию об этих фильмах, 
# однако, так как оценки им ещё не были выставлены, мы получили пропуски (NaN) на местах столбцов таблицы ratings_dates 
# (такие фильмы были записаны в конец таблицы).

# Метод merge() с внешним (outer) типом объединения может использоваться как аналог метода concat() 
# при объединении таблиц с одинаковой структурой (одинаковые количество и названия столбцов) по строкам. 
# В таком случае все одноимённые столбцы таблиц будут считаться ключевыми.
merge_ratings = ratings1.merge(ratings2, how='outer')
# Обратите внимание, что при использовании метода merge() для склейки двух таблиц у нас автоматически пропали дубликаты, 
# которые мы видели при использовании метода concat(). 
# Это особенность метода merge() — автоматическое удаление дублей.


# КАКОЙ МЕТОД ОБЪЕДИНЕНИЯ ИСПОЛЬЗОВАТЬ?
# Join() - таблицы связаны одинаковым ключем или индексом
# Merge(right_on='r_name', left_on='l_name') - таблицы связаны ключем или индексом с неодинаковыми именами
# Concat(axis=1) - таблицы не связаны ключем или индексом объединённые по столбцам
# Concat(axis=0) или Merge(how='outer') - таблицы не связаны ключем или индексом объединённые по строкам  и имеют одинаковую структуру данных
# Concat(axis=0) - таблицы не связаны ключем или индексом объединённые по строкам  и не имеют одинаковую структуру данных